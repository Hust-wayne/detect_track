# ---------------------------------------------------------
# IOU Tracker
# Written by wayne
# ---------------------------------------------------------

import cv2
from iouTrack.util import iou

class iou_track(object):
    def __init__(self):
        self.tracks_active = []

        self.tracks_id = 0


    def track_iou(self, detections, sigma_l, sigma_h, sigma_iou, t_min):
        """
        Simple IOU based tracker.
        See "High-Speed Tracking-by-Detection Without Using Image Information by E. Bochinski, V. Eiselein, T. Sikora" for
        more information.

        Args:
             detections (list): list of detections per frame, usually generated by util.load_mot
             sigma_l (float): low detection threshold.
             sigma_h (float): high detection threshold.
             sigma_iou (float): IOU threshold.
             t_min (float): minimum track length in frames.

        Returns:
            list: list of tracks.
        """
        tracks_finished = []
        dets = [det for det in detections if det[4] >= sigma_l]
        updated_tracks = []
        unmatched_tracks = []

        for track in self.tracks_active:
            if len(dets) > 0:
                # get det with highest iou
                best_match = max(dets, key=lambda x: iou(track['bboxes'][-1], x[:4]))
                if iou(track['bboxes'][-1], best_match[:4]) >= sigma_iou:
                    track['bboxes'].append(best_match[:4])
                    track['bboxes'] = track['bboxes'][-3:]
                    track['max_score'] = max(track['max_score'], best_match[4])

                    updated_tracks.append(track)

                    # remove from best matching detection from detections
                    del dets[dets.index(best_match)]
                else:
                    track['unmatch_times'] += 1
                    track['bboxes'] = track['bboxes'][-2:]
                    if track['unmatch_times'] < 3:
                        unmatched_tracks.append(track)

        # create new tracks
        new_tracks = [{'bboxes': [det[:4]], 'max_score': det[4], 'id': self.tracks_id+i, 'unmatch_times': 0} for i, det in enumerate(dets)]
        self.tracks_id += len(new_tracks)
        self.tracks_active = updated_tracks + new_tracks + unmatched_tracks

        # finish all remaining active tracks
        tracks_finished += [track for track in self.tracks_active
                            if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min]

        return tracks_finished

    @staticmethod
    def draw_bboxes(image, tracks_finished):
        clr = (0, 0, 255)
        for info in tracks_finished:
            bb = info['bboxes'][-1]
            tid = info['id']
            cv2.rectangle(image, (int(bb[0]), int(bb[1])),
                          (int(bb[2]), int(bb[3])), clr, 2)

            label = '_id:'+str(tid)

            (label_width, label_height), baseLine = cv2.getTextSize(
                label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)

            y_label = max(bb[1], label_height)

            cv2.rectangle(image, (int(bb[0]), int(y_label - label_height)),
                          (int(bb[0] + label_width), int(y_label + baseLine)),
                          (255, 255, 255), cv2.FILLED)
            cv2.putText(image, label, (int(bb[0]), int(y_label)),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, clr, 2)

        return image

