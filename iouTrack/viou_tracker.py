# ---------------------------------------------------------
# IOU Tracker
# Copyright (c) 2019 TU Berlin, Communication Systems Group
# Licensed under The MIT License [see LICENSE for details]
# Written by Erik Bochinski
# ---------------------------------------------------------

import cv2
import numpy as np
from lapsolver import solve_dense

from iouTrack.util import iou
from iouTrack.vis_tracker import VisTracker


class viou_track(object):
    def __init__(self, ttl, tracker_type):
        """
        Args:
            ttl (float): maximum number of frames to perform visual tracking.
                              this can fill 'gaps' of up to 2*ttl frames (ttl times forward and backward).
                 tracker_type (str): name of the visual tracker to use. see VisTracker for more details.
        """
        self.tracks_active = []
        self.tracks_extendable = []
        self.frame_buffer = []
        self.frame_num = 0
        self.tracker_id = 0
        self.ttl = ttl
        self.tracker_type = tracker_type
        if self.tracker_type == 'NONE':
            assert self.ttl == 1, "ttl should not be larger than 1 if no visual tracker is selected"


    def track_viou(self, frame, detections, sigma_l, sigma_h, sigma_iou, t_min, keep_upper_height_ratio):
        """ V-IOU Tracker.
        See "Extending IOU Based Multi-Object Tracking by Visual Information by E. Bochinski, T. Senst, T. Sikora" for
        more information.

        Args:
             detections (list): list of detections per frame, usually generated by util.load_mot
             sigma_l (float): low detection threshold.
             sigma_h (float): high detection threshold.
             sigma_iou (float): IOU threshold.
             t_min (float): minimum track length in frames.
             keep_upper_height_ratio (float): float between 0.0 and 1.0 that determines the ratio of height of the object
                                              to track to the total height of the object used for visual tracking.

        Returns:
            list: list of tracks.
        """


        tracks_finished = []

        self.frame_num += 1

        # load frame and put into buffer
        self.frame_buffer.append(frame)
        if len(self.frame_buffer) > self.ttl + 1:
            self.frame_buffer.pop(0)

        # apply low threshold to detections
        dets = [det for det in detections if det[4] >= sigma_l]

        track_ids, det_ids = self.associate(self.tracks_active, dets, sigma_iou)
        updated_tracks = []
        for track_id, det_id in zip(track_ids, det_ids):
            self.tracks_active[track_id]['bboxes'].append(dets[det_id][:4])
            self.tracks_active[track_id]['max_score'] = max(self.tracks_active[track_id]['max_score'], dets[det_id][4])
            self.tracks_active[track_id]['classes'].append(dets[det_id][5])
            self.tracks_active[track_id]['det_counter'] += 1

            if self.tracks_active[track_id]['ttl'] != self.ttl:
                # reset visual tracker if active
                self.tracks_active[track_id]['ttl'] = self.ttl
                self.tracks_active[track_id]['visual_tracker'] = None

            updated_tracks.append(self.tracks_active[track_id])

        tracks_not_updated = [self.tracks_active[idx] for idx in set(range(len(self.tracks_active))).difference(set(track_ids))]

        for track in tracks_not_updated:
            if track['ttl'] > 0:
                if track['ttl'] == self.ttl:
                    # init visual tracker
                    track['visual_tracker'] = VisTracker(self.tracker_type, track['bboxes'][-1], self.frame_buffer[-2],
                                                         keep_upper_height_ratio)
                # viou forward update
                ok, bbox = track['visual_tracker'].update(frame)

                if not ok:
                    # visual update failed, track can still be extended
                    self.tracks_extendable.append(track)
                    continue

                track['ttl'] -= 1
                track['bboxes'].append(bbox)
                updated_tracks.append(track)
            else:
                self.tracks_extendable.append(track)

        # update the list of extendable tracks. tracks that are too old are moved to the finished_tracks. this should
        # not be necessary but may improve the performance for large numbers of tracks (eg. for mot19)
        tracks_extendable_updated = []
        for track in self.tracks_extendable:
            if track['start_frame'] + len(track['bboxes']) + self.ttl - track['ttl'] >= self.frame_num:
                tracks_extendable_updated.append(track)
            elif track['max_score'] >= sigma_h and track['det_counter'] >= t_min:
                tracks_finished.append(track)
        self.tracks_extendable = tracks_extendable_updated

        new_dets = [dets[idx] for idx in set(range(len(dets))).difference(set(det_ids))]
        dets_for_new = []

        for det in new_dets:
            finished = False
            # go backwards and track visually
            boxes = []
            vis_tracker = VisTracker(self.tracker_type, det[:4], frame, keep_upper_height_ratio)

            for f in reversed(self.frame_buffer[:-1]):
                ok, bbox = vis_tracker.update(f)
                if not ok:
                    # can not go further back as the visual tracker failed
                    break
                boxes.append(bbox)

                # sorting is not really necessary but helps to avoid different behaviour for different orderings
                # preferring longer tracks for extension seems intuitive, LAP solving might be better
                for track in sorted(self.tracks_extendable, key=lambda x: len(x['bboxes']), reverse=True):

                    offset = track['start_frame'] + len(track['bboxes']) + len(boxes) - self.frame_num
                    # association not optimal (LAP solving might be better)
                    # association is performed at the same frame, not adjacent ones
                    if 1 <= offset <= self.ttl - track['ttl'] and iou(track['bboxes'][-offset], bbox) >= sigma_iou:
                        if offset > 1:
                            # remove existing visually tracked boxes behind the matching frame
                            track['bboxes'] = track['bboxes'][:-offset+1]
                        track['bboxes'] += list(reversed(boxes))[1:]
                        track['bboxes'].append(det[:4])
                        track['max_score'] = max(track['max_score'], det[4])
                        track['classes'].append(det[5])
                        track['ttl'] = self.ttl
                        track['visual_tracker'] = None

                        self.tracks_extendable.remove(track)
                        if track in tracks_finished:
                            del tracks_finished[tracks_finished.index(track)]
                        updated_tracks.append(track)

                        finished = True
                        break
                if finished:
                    break
            if not finished:
                dets_for_new.append(det)

        # create new tracks
        new_tracks = [{'bboxes': [det[:4]], 'max_score': det[4], 'start_frame': self.frame_num, 'ttl': self.ttl,
                       'classes': [det[5]], 'det_counter': 1, 'visual_tracker': None, 'id': self.tracker_id+i} for i, det in enumerate(dets_for_new)]
        self.tracker_id += len(new_tracks)
        self.tracks_active = []
        for track in updated_tracks + new_tracks:
            if track['ttl'] == 0:
                self.tracks_extendable.append(track)
            else:
                self.tracks_active.append(track)

        # finish all remaining active and extendable tracks
        tracks_finished = tracks_finished + \
                          [track for track in self.tracks_active + self.tracks_extendable
                           if track['max_score'] >= sigma_h and track['det_counter'] >= t_min]

        # remove last visually tracked frames and compute the track classes
        for track in tracks_finished:
            if self.ttl != track['ttl']:
                track['bboxes'] = track['bboxes'][:-(self.ttl - track['ttl'])]
            track['class'] = max(set(track['classes']), key=track['classes'].count)

            if track.get('visual_tracker', 0):
                del track['visual_tracker']

        return tracks_finished


    def associate(self, tracks, detections, sigma_iou):
        """ perform association between tracks and detections in a frame.
        Args:
            tracks (list): input tracks
            detections (list): input detections
            sigma_iou (float): minimum intersection-over-union of a valid association

        Returns:
            (tuple): tuple containing:

            track_ids (numpy.array): 1D array with indexes of the tracks
            det_ids (numpy.array): 1D array of the associated indexes of the detections
        """
        costs = np.empty(shape=(len(tracks), len(detections)), dtype=np.float32)
        for row, track in enumerate(tracks):
            for col, detection in enumerate(detections):
                costs[row, col] = 1 - iou(track['bboxes'][-1], detection[:4])

        np.nan_to_num(costs)
        costs[costs > 1 - sigma_iou] = np.nan
        track_ids, det_ids = solve_dense(costs)

        return track_ids, det_ids


    @staticmethod
    def draw_bboxes(image, tracks_finished):
        clr = (0, 0, 255)
        for info in tracks_finished:
            bb = info['bboxes'][-1]
            tid = info['id']
            cv2.rectangle(image, (int(bb[0]), int(bb[1])),
                          (int(bb[2]), int(bb[3])), clr, 2)

            label = '_id:'+str(tid)

            (label_width, label_height), baseLine = cv2.getTextSize(
                label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)

            y_label = max(bb[1], label_height)

            cv2.rectangle(image, (int(bb[0]), int(y_label - label_height)),
                          (int(bb[0] + label_width), int(y_label + baseLine)),
                          (255, 255, 255), cv2.FILLED)
            cv2.putText(image, label, (int(bb[0]), int(y_label)),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, clr, 2)

        return image
